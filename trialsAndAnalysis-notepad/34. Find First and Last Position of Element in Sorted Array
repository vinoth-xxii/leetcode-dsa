class Solution {
    public int[] searchRange(int[] nums, int target) {
        //O(n) time approach
        for(int i = 0; i < nums.length; i++){  //O(n) time
            if(nums[i] == target){
                List<Integer> list = new ArrayList<>(); //O(n) space
                list.add(i++);
                while(i < nums.length && nums[i] == target){ //O(n) time
                    list.add(i++);
                }
                //they are just asking the first and last indeces
                return new int[]{list.get(0), list.get(list.size()-1)}; //O(1)
            }
        }
        return new int[]{-1,-1};
    }
}

//
class Solution {
    int min = -1;
    int max = -1;
    int target;
    int arr[];

    public void setMinMax(int left, int right){
        if(left==right){
            if(arr[left] == target){
                if(left < min) min = left;
                if(right > max) max = right;
                return;
            }
            return;
        }
        int mid = (right-left)/ 2 - left;
        setMinMax(left, mid);
        setMinMax(mid+1,right);
    }

    public int[] searchRange(int[] nums, int target) {
        this.target = target;
        this.arr = nums;
        int left = 0;
        int right = nums.length - 1;
        setMinMax(left, right);
        return new int[] { min, max };
    }
}

throws runTime error in leetCode:
java.lang.StackOverflowError
  at line 17, Solution.setMinMax
  
  
// Corrected Code
class Solution {
    int min = Integer.MAX_VALUE;
    int max = -1;
    int target;
    int[] arr;

    public void setMinMax(int left, int right) {
        if (left > right) return;

        if (left == right) {
            if (arr[left] == target) {
                min = Math.min(min, left);
                max = Math.max(max, left);
            }
            return;
        }

        int mid = left + (right - left) / 2;

        setMinMax(left, mid);
        setMinMax(mid + 1, right);
    }

    public int[] searchRange(int[] nums, int target) {
        this.target = target;
        this.arr = nums;

        setMinMax(0, nums.length - 1);

        if (min == Integer.MAX_VALUE) return new int[]{-1, -1};
        return new int[]{min, max};
    }
}

//With some more optimisation
class Solution {
    // Just tried with divide and conquer approach - no time improvement
    int min = Integer.MAX_VALUE;
    int max = -1;
    int target;
    int arr[];

    public void setMinMax(int left, int right) {
        if (left > right)
            return;

        if (left == right) {
            if (arr[left] == target) {
                if (left < min)
                    min = left;
                if (right > max)
                    max = right;
                return;
            }
            return;
        }
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) { //might be optimal compared to previous once
            setMinMax(left, mid);
            setMinMax(mid + 1, right);
        }
        else if(arr[mid] < target)  setMinMax(mid + 1, right);
        else  setMinMax(left, mid);

    }

    public int[] searchRange(int[] nums, int target) {
        this.target = target;
        this.arr = nums;
        int left = 0;
        int right = nums.length - 1;
        setMinMax(left, right);
        if (min == Integer.MAX_VALUE)
            return new int[] { -1, -1 };
        return new int[] { min, max };
    }
}

//Yet Another attempt
class Solution {
    int left = 0;
    int right, mid;
    int min = Integer.MAX_VALUE;
    int target;
    int max = -1;
    int arr[];

    public void binarySearch(int left, int right) {
        if (left > right)
            return;

        mid = (right - left) / 2 + left;
        if (arr[mid] == target) {
            min = Math.min(min, mid);   //warn
            max = Math.max(max, mid);   //warn
            binarySearch(left,  mid - 1); //warn
            binarySearch(mid + 1, right);
        } else if (arr[mid] > target) {
            binarySearch(left, mid - 1);  //warn
        } else
            binarySearch(mid + 1, right);

    }

    public int[] searchRange(int[] nums, int target) {
        //Worst Case O(log n) is pretty trick here
        //In discussions they said two binary seaches 2logn
        this.arr = nums;
        this.target = target;
        right = nums.length - 1;
        binarySearch(left, right);

        if (min == Integer.MAX_VALUE)
            return new int[] { -1, -1 };
        return new int[] { min, max };
    }
}

